#include <iostream>
using namespace std;

/********************************************************************

* 对象作为功能与数据的载体，从逻辑上应该可以进行运算载
  比如：对象 A + 对象 C，但是已存在的算数规则不能直接应用在对象上
  因为对象的数据成员是自定义了，存在无数种可能性，没办法统一运算规则
  它不像 3 + 3 这种算数，算数是唯一的，不存在多种情况。

* 所以 C++提供了可以对运算符功能拓展的语法特性，叫重载运算符/运算符重载
  前面学习过函数重载，函数重载就是函数名一样，参数列表不一样
  运算符重载就是针对一个运算符，操作数不一样，出现了对象

* 比如：
  12 + 13 这是默认存在的，数据作为操作数的加法
  对象 + 13 这是需要我们重载加法运算符，以计算这个操作数
  13 + 对象
  对象 + 对象
        这两个加法 + ，即是重载的关系，所以叫运算符重载

* 所以，运算符重载要求其中一个操作数必须是对象
********************************************************************/

/*************************************************************
 * 实现两个数组相加，类内重载运算符
 *************************************************************/

class Arr
{
private:
    int a[5];  // 固定5个元素，不用写复杂的
public:
    Arr(int arr[])
    {
        for (int i = 0; i < 5; i++)
            this->a[i] = arr[i];
    }
    /****************************************************************
    * 类内运算符重载形式： 对象 + 数组
    * 函数名：关键字 operator 后接一个运算符+
    * 参数：  类内重载，左操作数默认是当前类的对象，参数是右操作数
    * 返回值： 返回一个装加后数组的新的对象，可以实现累加
            也可以是 void，但是不能累加了
    * 注意点：此函数是自定义，所以其内代码是任意的，但是不能违背常理
    ****************************************************************/
    Arr operator+ (int a[])       //  参数是一个数组   实现：对象+数组
    {
        int temp[5];
        for (int i = 0; i < 5; i++)
            temp[i] = this->a[i] + a[i];
        return Arr(temp);
    }
    Arr operator+ (const Arr& tp)  //  参数是一个对象，实现：对象+对象
    {
        int temp[5];
        for (int i = 0; i < 5; i ++)
            temp[i] = this->a[i] + tp.a[i];
        return Arr(temp);
    }

    void Print()
    {
        for (int i = 0; i < 5; i++)
        cout << a[i] << ' ';
        cout << endl;
    }
};


int main(void)
{
/****************************************************************
* 实现两个数组的加法运算，即 a + c，暂定规则是各元素对应相加
****************************************************************/

    int a[5] = { 1,2,3,4,5 };
    int c[5] = { 9,8,7,6,0 };
    //a + c; //这语法直接报错

/****************************************************************
* 没有 a+c 这种数组相加的加法，所以我们要重载+法
* 重载运算符必须至少一个操作数是对象，所以我们创建一个数组类
* 实现第一种：对象 + 数组，左操作数是对象
****************************************************************/

    Arr AA(a), CC(c); //定义对象初始化，走构造函数
    Arr tp = AA + c; //对象 + 数组
    //此处加法结果返回值是 Arr，初始化给 tp，走默认 拷贝构造
    tp.Print(); //tp 对象装着加完后的数组

/****************************************************************
* 实现第二种：对象 + 对象，左操作数是对象
****************************************************************/

    Arr td = AA + CC; //对象 + 对象
    td.Print();

/****************************************************************
* 实现第三种：数组 + 对象
* 此时需要类外重载，因为类内重载左操作数默认是对象
* 见下一cpp
****************************************************************/

    return 0;
}


    /****************************************************************
    * 编译器对运算符重载的隐式翻译过程
    * 核心规则：类内成员函数版运算符重载，左操作数 = 调用函数的对象（this 指向）
    * 1. 表达式：AA + c  → 编译器翻译为：AA.operator+(c)
    *    - 左操作数 AA：隐式作为 this 指针指向的对象，无需传参
    *    - 右操作数 c：作为成员函数 operator+ 的显式参数传递
    *    - 功能：调用 AA 的 operator+(int a[]) 成员函数，完成对象 + 数组
    * 2. 表达式：AA + CC → 编译器翻译为：AA.operator+(CC)
    *    - 左操作数 AA：隐式作为 this 指针指向的对象，无需传参
    *    - 右操作数 CC：作为成员函数 operator+ 的显式参数（const Arr& tp）传递
    *    - 功能：调用 AA 的 operator+(const Arr& tp) 成员函数，完成对象 + 对象
    * 3. 关键对比：若为全局函数版重载，翻译形式为 operator+(左操作数, 右操作数)
    *    - 例如全局函数 Arr operator+(const Arr& obj, int a[])
    *    - 表达式 AA + c 会翻译为 operator+(AA, c)，两个操作数都需显式传递
    ****************************************************************/

