#include <iostream>
using namespace std;

/******************************************************
析构函数
对象生命周期结束时自动调用的函数形式：
*******************************************************/

class Test
{
private:
    int a;
public:
    Test(int aa)
    {
        a = aa;
        cout << a << "构造函数" << endl;
    }

    // 析构函数 只有一个，不可函数重载 不写默认有
    ~Test()   //无返回值，无参数，函数名为类名，前带符号 ~
    {
        cout << a << "析构函数" << endl;
    }
};

int main()
{
    Test t1(1);                   //t1 开始
    {
        Test t2(2);               //t2 开始
    }                 //t2 结束
    Test* t3;
    t3 = new Test(3);             //t3 开始
    // delete 先调用析构函数，再释放内存
    delete t3;        //t3 结束                

    return 0;
}                     //t1 结束

 
/*******************************************************
 
 C++ 析构函数调用机制详解

*******************************************************/
 
/*
1. - 栈对象 (Stack Object) —— 自动调用
- 当你在函数里直接定义对象（如 Test t;）时，它存储在栈（Stack）上。
- C++ 遵循 "作用域规则"：
- - 当程序执行流进入 {} 时，对象构造。
- - 当程序执行流离开 {} 时（哪怕是遇到 return 或 发生异常），
- 编译器会自动插入代码调用析构函数。
- 特点：不需要手动写 delete，不用担心内存泄漏，非常安全。
*/
 
/*
2. - 堆对象 (Heap Object) —— 手动调用
- 当你用 new 创建对象（如 Test *p = new Test;）时，它存储在堆（Heap）上。
- 堆内存不受作用域限制，对象创建后会一直存在，直到你显式销毁它。
- 强制规则：
- - 必须配对使用：new <-> delete。
- - 当你执行 delete p; 时，编译器做了两件事：
1. - 先调用 p 指向对象的析构函数（清理资源）。
2. - 再释放这块内存（归还给系统）。
- 后果：如果忘了写 delete，析构函数永远不会被调用 -> 内存泄漏。
*/
 
/*
3. - 总结对比
- 类型      创建方式         销毁方式        谁来调用析构
-  
- 栈对象     Test t;        离开作用域       编译器自动调用
- 堆对象     new Test;      delete p;      程序员手动触发
*/
