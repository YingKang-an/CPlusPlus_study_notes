#include<iostream>
using namespace std;

/***********************************************
 * 调用时机
 * 新建一个对象，用已存在的同类对象对其初始化，调用拷贝构造
 * 各种情况如下演示
***********************************************************/
class Test
{
public:
    Test(int a)
    {
        cout << "普通构造" << endl;
    }
    Test(const Test& t) //参数为当前类的常量引用类型
    {
        cout << "拷贝构造" << endl;
    }
};

Test Fun(Test s)//自定义函数，返回值与参数都是对象
{
    return s;
}  

int main(void)
{

    Test t1(12);             //走普通构造

    Test t2(t1);             //情况 1：t1 给 t2 初始化，走拷贝构造

    Test t3 = t2;            //情况 2：t2 给 t3 初始化，走拷贝构造

    Test t4 = Test(12);      //情况 3：具体实现取决于编译器，两种情况
    //1、直接用 12 给 t4 初始化，走一次普通构造
    //2、Test(12)构建一个『临时对象』12 给临时对象初始化，走一次普通构造

    Test* t5 = new Test(t4);  // 不是临时对象
    //情况 4：t4 给 t5 指向的空间(匿名对象)初始化，走拷贝构
    //然后临时对象给 t4 初始化，再走一次拷贝构造

    Test t6 = Fun(t1);
    //情况 5：调用是实参给形参初始化，即 Test s = t1; 走一次拷贝构造
    //情况 6：函数返回值，两种情况，具体实现取决于编译器
    //1、Fun 函数返回值直接给 t6 初始化，即 Test t6 = s; 走一次拷贝构造，
    //2、有的编译器在返回值生成临时对象，将 s 初始化给临时对象，走一次构造函数
    //   然后临时对象初始化给 t6，即 Test t6 = 临时对象; 再走一次拷贝构造

    return 0;
}
