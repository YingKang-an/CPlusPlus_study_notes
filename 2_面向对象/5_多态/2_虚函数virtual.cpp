#include <iostream>
using namespace std;

// 如何让父类指针调用子类的函数呢？ 虚函数
// 虚函数的语法形式
// 1、派生类重写基类函数，即函数头一样
// 2、基类函数定义成虚函数，virtual

// 基类 CA
class CA
{
public:
    // 给成员函数加 virtual 关键字：开启动态绑定（运行时决定调用哪个函数）
    virtual void fun() 
    { 
        cout << "CA::fun() 基类自己的虚函数" << endl; 
    }

    // 基类析构函数也加 virtual：确保删除基类指针时，先调用子类析构
    virtual ~CA() = default;  //  = default; ：默认函数生成
};

// 子类 CC，公有继承自基类 CA
class CC : public CA
{
public:
    // override 关键字：显式声明重写基类的虚函数（可选，但建议加，编译器会检查匹配性）
    void fun() override 
    { 
        cout << "CC::fun() 子类重写的虚函数" << endl; 
    }
};

int main()
{
    /************************ 情况1：基类指针 指向 子类对象 ************************/
    // new CC：在堆上创建一个子类 CC 的对象，返回其首地址
    // CA* p1：基类指针接收该地址（语法合法，因为子类包含基类部分）
    CA* p1 = new CC;
    // 调用虚函数 fun()：
    // 因为 fun() 是 virtual，所以运行时会根据 p1 实际指向的对象类型（CC）来调用函数
    // 最终执行的是 子类 CC 重写的 fun()
    p1->fun(); // 输出：CC::fun() 子类重写的虚函数

    /************************ 情况2：基类指针 指向 基类对象 ************************/
    // new CA：在堆上创建一个基类 CA 的对象，返回其首地址
    // CA* p2：基类指针接收该地址
    CA* p2 = new CA;
    // 调用虚函数 fun()：
    // 实际指向的对象是基类 CA，所以执行的是 基类自己的 fun()
    // 这证明：virtual 不是强制调用子类函数，只是看实际对象是谁
    p2->fun(); // 输出：CA::fun() 基类自己的虚函数

    /************************ 情况3：基类对象 直接调用 ************************/
    // 创建基类的局部对象 a
    CA a;
    // 直接调用 fun()：对象是基类 CA，所以执行基类自己的 fun()
    // 基类的虚函数依然可以被自己的对象调用，不受影响
    a.fun(); // 输出：CA::fun() 基类自己的虚函数

    // 释放堆内存
    delete p1;
    delete p2;

    return 0;
}
// 所以，虚函数的作用是使得父类的指针或者引用，指向子类的对象，便可以调用
// 子类重写父类虚函数的成员
